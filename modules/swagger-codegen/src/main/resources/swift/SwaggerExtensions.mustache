// Request+Promise.swift
//
// Generated by swagger-codegen
// https://github.com/swagger-api/swagger-codegen
//

import Alamofire
import PromiseKit
import SwiftyJSON

extension Request {
    func responsePromise<T>() -> Promise<Response<T>> {
        return Promise<Response<T>> { [unowned self] (resolve, reject) in
            self.responseJSON(options: .AllowFragments) { (req, res, json, error) in
                if let error = error {
                    reject(error)
                    return
                }
                if let json: AnyObject = json {
                    if let body = T.decode(json) {
                        let response = Response(header: res!.allHeaderFields, body: body)
                        resolve(response)
                    } else {
                        reject(NSError(domain: "localhost", code: 500, userInfo: ["reason": "cannot convertible: \(json)"]))
                    }
                    return
                }

                reject(NSError(domain: "localhost", code: 500, userInfo: ["reason": "unreacheable code"]))
            }
        }
    }
}

extension Array: JSONEncodable {
    func encode() -> Any {
        if Element.self is JSONEncodable {
            let mapped: [Any] = self.map { (element) in
                let encodable = (element as? JSONEncodable)!
                return encodable
            }
            return mapped
        } else {
            return self
        }
    }
}

extension JSON {
    func decode() -> Bool? {
        return self.bool
    }
    func decode() -> Bool {
        return self.boolValue
    }
    func decode() -> Int? {
        return self.int
    }
    func decode() -> Int {
        return self.intValue
    }
    func decode() -> Float? {
        return self.float
    }
    func decode() -> Float {
        return self.floatValue
    }
    func decode() -> Double? {
        return self.double
    }
    func decode() -> Double {
        return self.doubleValue
    }
    func decode() -> String? {
        return self.string
    }
    func decode() -> String {
        return self.stringValue
    }
    func decode<T: JSONDecodable>() -> T? {
        return T.decode(self.object)
    }
    func decode<T: JSONDecodable>() -> [T]? {
        return self.arrayObject?.map(T.decode).filter({ $0 != nil }).map({ $0! })
    }
}
